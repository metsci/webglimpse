
declare module Webglimpse {
    var GL: {
        DEPTH_FUNC: number;
        DEPTH_COMPONENT16: number;
        REPLACE: number;
        REPEAT: number;
        VERTEX_ATTRIB_ARRAY_ENABLED: number;
        FRAMEBUFFER_INCOMPLETE_DIMENSIONS: number;
        STENCIL_BUFFER_BIT: number;
        RENDERER: number;
        STENCIL_BACK_REF: number;
        TEXTURE26: number;
        RGB565: number;
        DITHER: number;
        CONSTANT_COLOR: number;
        GENERATE_MIPMAP_HINT: number;
        POINTS: number;
        DECR: number;
        INT_VEC3: number;
        TEXTURE28: number;
        ONE_MINUS_CONSTANT_ALPHA: number;
        BACK: number;
        RENDERBUFFER_STENCIL_SIZE: number;
        UNPACK_FLIP_Y_WEBGL: number;
        BLEND: number;
        TEXTURE9: number;
        ARRAY_BUFFER_BINDING: number;
        MAX_VIEWPORT_DIMS: number;
        INVALID_FRAMEBUFFER_OPERATION: number;
        TEXTURE: number;
        TEXTURE0: number;
        TEXTURE31: number;
        TEXTURE24: number;
        HIGH_INT: number;
        RENDERBUFFER_BINDING: number;
        BLEND_COLOR: number;
        FASTEST: number;
        STENCIL_WRITEMASK: number;
        ALIASED_POINT_SIZE_RANGE: number;
        TEXTURE12: number;
        DST_ALPHA: number;
        BLEND_EQUATION_RGB: number;
        FRAMEBUFFER_COMPLETE: number;
        NEAREST_MIPMAP_NEAREST: number;
        VERTEX_ATTRIB_ARRAY_SIZE: number;
        TEXTURE3: number;
        DEPTH_WRITEMASK: number;
        CONTEXT_LOST_WEBGL: number;
        INVALID_VALUE: number;
        TEXTURE_MAG_FILTER: number;
        ONE_MINUS_CONSTANT_COLOR: number;
        ONE_MINUS_SRC_ALPHA: number;
        TEXTURE_CUBE_MAP_POSITIVE_Z: number;
        NOTEQUAL: number;
        ALPHA: number;
        DEPTH_STENCIL: number;
        MAX_VERTEX_UNIFORM_VECTORS: number;
        DEPTH_COMPONENT: number;
        RENDERBUFFER_RED_SIZE: number;
        TEXTURE20: number;
        RED_BITS: number;
        RENDERBUFFER_BLUE_SIZE: number;
        SCISSOR_BOX: number;
        VENDOR: number;
        FRONT_AND_BACK: number;
        CONSTANT_ALPHA: number;
        VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: number;
        NEAREST: number;
        CULL_FACE: number;
        ALIASED_LINE_WIDTH_RANGE: number;
        TEXTURE19: number;
        FRONT: number;
        DEPTH_CLEAR_VALUE: number;
        GREEN_BITS: number;
        TEXTURE29: number;
        TEXTURE23: number;
        MAX_RENDERBUFFER_SIZE: number;
        STENCIL_ATTACHMENT: number;
        TEXTURE27: number;
        BOOL_VEC2: number;
        OUT_OF_MEMORY: number;
        MIRRORED_REPEAT: number;
        POLYGON_OFFSET_UNITS: number;
        TEXTURE_MIN_FILTER: number;
        STENCIL_BACK_PASS_DEPTH_PASS: number;
        LINE_LOOP: number;
        FLOAT_MAT3: number;
        TEXTURE14: number;
        LINEAR: number;
        RGB5_A1: number;
        ONE_MINUS_SRC_COLOR: number;
        SAMPLE_COVERAGE_INVERT: number;
        DONT_CARE: number;
        FRAMEBUFFER_BINDING: number;
        RENDERBUFFER_ALPHA_SIZE: number;
        STENCIL_REF: number;
        ZERO: number;
        DECR_WRAP: number;
        SAMPLE_COVERAGE: number;
        STENCIL_BACK_FUNC: number;
        TEXTURE30: number;
        VIEWPORT: number;
        STENCIL_BITS: number;
        FLOAT: number;
        COLOR_WRITEMASK: number;
        SAMPLE_COVERAGE_VALUE: number;
        TEXTURE_CUBE_MAP_NEGATIVE_Y: number;
        STENCIL_BACK_FAIL: number;
        FLOAT_MAT4: number;
        UNSIGNED_SHORT_4_4_4_4: number;
        TEXTURE6: number;
        RENDERBUFFER_WIDTH: number;
        RGBA4: number;
        ALWAYS: number;
        BLEND_EQUATION_ALPHA: number;
        COLOR_BUFFER_BIT: number;
        TEXTURE_CUBE_MAP: number;
        DEPTH_BUFFER_BIT: number;
        STENCIL_CLEAR_VALUE: number;
        BLEND_EQUATION: number;
        RENDERBUFFER_GREEN_SIZE: number;
        NEAREST_MIPMAP_LINEAR: number;
        VERTEX_ATTRIB_ARRAY_TYPE: number;
        INCR_WRAP: number;
        ONE_MINUS_DST_COLOR: number;
        HIGH_FLOAT: number;
        BYTE: number;
        FRONT_FACE: number;
        SAMPLE_ALPHA_TO_COVERAGE: number;
        CCW: number;
        TEXTURE13: number;
        MAX_VERTEX_ATTRIBS: number;
        MAX_VERTEX_TEXTURE_IMAGE_UNITS: number;
        TEXTURE_WRAP_T: number;
        UNPACK_PREMULTIPLY_ALPHA_WEBGL: number;
        FLOAT_VEC2: number;
        LUMINANCE: number;
        GREATER: number;
        INT_VEC2: number;
        VALIDATE_STATUS: number;
        FRAMEBUFFER: number;
        FRAMEBUFFER_UNSUPPORTED: number;
        TEXTURE5: number;
        FUNC_SUBTRACT: number;
        BLEND_DST_ALPHA: number;
        SAMPLER_CUBE: number;
        ONE_MINUS_DST_ALPHA: number;
        LESS: number;
        TEXTURE_CUBE_MAP_POSITIVE_X: number;
        BLUE_BITS: number;
        DEPTH_TEST: number;
        VERTEX_ATTRIB_ARRAY_STRIDE: number;
        DELETE_STATUS: number;
        TEXTURE18: number;
        POLYGON_OFFSET_FACTOR: number;
        UNSIGNED_INT: number;
        TEXTURE_2D: number;
        DST_COLOR: number;
        FLOAT_MAT2: number;
        COMPRESSED_TEXTURE_FORMATS: number;
        MAX_FRAGMENT_UNIFORM_VECTORS: number;
        DEPTH_STENCIL_ATTACHMENT: number;
        LUMINANCE_ALPHA: number;
        CW: number;
        VERTEX_ATTRIB_ARRAY_NORMALIZED: number;
        TEXTURE_CUBE_MAP_NEGATIVE_Z: number;
        LINEAR_MIPMAP_LINEAR: number;
        BUFFER_SIZE: number;
        SAMPLE_BUFFERS: number;
        TEXTURE15: number;
        ACTIVE_TEXTURE: number;
        VERTEX_SHADER: number;
        TEXTURE22: number;
        VERTEX_ATTRIB_ARRAY_POINTER: number;
        INCR: number;
        COMPILE_STATUS: number;
        MAX_COMBINED_TEXTURE_IMAGE_UNITS: number;
        TEXTURE7: number;
        UNSIGNED_SHORT_5_5_5_1: number;
        DEPTH_BITS: number;
        RGBA: number;
        TRIANGLE_STRIP: number;
        COLOR_CLEAR_VALUE: number;
        BROWSER_DEFAULT_WEBGL: number;
        INVALID_ENUM: number;
        SCISSOR_TEST: number;
        LINE_STRIP: number;
        FRAMEBUFFER_INCOMPLETE_ATTACHMENT: number;
        STENCIL_FUNC: number;
        FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: number;
        RENDERBUFFER_HEIGHT: number;
        TEXTURE8: number;
        TRIANGLES: number;
        FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: number;
        STENCIL_BACK_VALUE_MASK: number;
        TEXTURE25: number;
        RENDERBUFFER: number;
        LEQUAL: number;
        TEXTURE1: number;
        STENCIL_INDEX8: number;
        FUNC_ADD: number;
        STENCIL_FAIL: number;
        BLEND_SRC_ALPHA: number;
        BOOL: number;
        ALPHA_BITS: number;
        LOW_INT: number;
        TEXTURE10: number;
        SRC_COLOR: number;
        MAX_VARYING_VECTORS: number;
        BLEND_DST_RGB: number;
        TEXTURE_BINDING_CUBE_MAP: number;
        STENCIL_INDEX: number;
        TEXTURE_BINDING_2D: number;
        MEDIUM_INT: number;
        SHADER_TYPE: number;
        POLYGON_OFFSET_FILL: number;
        DYNAMIC_DRAW: number;
        TEXTURE4: number;
        STENCIL_BACK_PASS_DEPTH_FAIL: number;
        STREAM_DRAW: number;
        MAX_CUBE_MAP_TEXTURE_SIZE: number;
        TEXTURE17: number;
        TRIANGLE_FAN: number;
        UNPACK_ALIGNMENT: number;
        CURRENT_PROGRAM: number;
        LINES: number;
        INVALID_OPERATION: number;
        FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: number;
        LINEAR_MIPMAP_NEAREST: number;
        CLAMP_TO_EDGE: number;
        RENDERBUFFER_DEPTH_SIZE: number;
        TEXTURE_WRAP_S: number;
        ELEMENT_ARRAY_BUFFER: number;
        UNSIGNED_SHORT_5_6_5: number;
        ACTIVE_UNIFORMS: number;
        FLOAT_VEC3: number;
        NO_ERROR: number;
        ATTACHED_SHADERS: number;
        DEPTH_ATTACHMENT: number;
        TEXTURE11: number;
        STENCIL_TEST: number;
        ONE: number;
        FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: number;
        STATIC_DRAW: number;
        GEQUAL: number;
        BOOL_VEC4: number;
        COLOR_ATTACHMENT0: number;
        PACK_ALIGNMENT: number;
        MAX_TEXTURE_SIZE: number;
        STENCIL_PASS_DEPTH_FAIL: number;
        CULL_FACE_MODE: number;
        TEXTURE16: number;
        STENCIL_BACK_WRITEMASK: number;
        SRC_ALPHA: number;
        UNSIGNED_SHORT: number;
        TEXTURE21: number;
        FUNC_REVERSE_SUBTRACT: number;
        SHADING_LANGUAGE_VERSION: number;
        EQUAL: number;
        FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: number;
        BOOL_VEC3: number;
        SAMPLER_2D: number;
        TEXTURE_CUBE_MAP_NEGATIVE_X: number;
        MAX_TEXTURE_IMAGE_UNITS: number;
        TEXTURE_CUBE_MAP_POSITIVE_Y: number;
        RENDERBUFFER_INTERNAL_FORMAT: number;
        STENCIL_VALUE_MASK: number;
        ELEMENT_ARRAY_BUFFER_BINDING: number;
        ARRAY_BUFFER: number;
        DEPTH_RANGE: number;
        NICEST: number;
        ACTIVE_ATTRIBUTES: number;
        NEVER: number;
        FLOAT_VEC4: number;
        CURRENT_VERTEX_ATTRIB: number;
        STENCIL_PASS_DEPTH_PASS: number;
        INVERT: number;
        LINK_STATUS: number;
        RGB: number;
        INT_VEC4: number;
        TEXTURE2: number;
        UNPACK_COLORSPACE_CONVERSION_WEBGL: number;
        MEDIUM_FLOAT: number;
        SRC_ALPHA_SATURATE: number;
        BUFFER_USAGE: number;
        SHORT: number;
        NONE: number;
        UNSIGNED_BYTE: number;
        INT: number;
        SUBPIXEL_BITS: number;
        KEEP: number;
        SAMPLES: number;
        FRAGMENT_SHADER: number;
        LINE_WIDTH: number;
        BLEND_SRC_RGB: number;
        LOW_FLOAT: number;
        VERSION: number;
    };
    function hasval(value: any): boolean;
    function isNumber(value: any): boolean;
    function isString(value: any): boolean;
    function isEmpty(array: any[]): boolean;
    function notEmpty(array: any[]): boolean;
    function alwaysTrue(): boolean;
    function alwaysFalse(): boolean;
    function constantFn<V>(value: V): () => V;
    function log10(x: number): number;
    function order(x: number): number;
    function clamp(xMin: number, xMax: number, x: number): number;
    function copyArray<T>(values: T[]): T[];
    function ensureCapacityFloat32(buffer: Float32Array, minNewCapacity: number): Float32Array;
    function ensureCapacityUint32(buffer: Uint32Array, minNewCapacity: number): Uint32Array;
    function ensureCapacityUint16(buffer: Uint16Array, minNewCapacity: number): Uint16Array;
    interface StringMap<V> {
        [key: string]: V;
    }
    interface IdFunction<V> {
        (value: V): string;
    }
    var getObjectId: (obj: any) => string;
    function concatLines(...lines: string[]): string;
    /**
    * Parses a timestamp from the format 'YYYY-MM-DDTHH:mm:ss[.SSS]ZZ' into posix-milliseconds.
    *
    * Format examples:
    *   - '2014-01-01T00:00:00Z'
    *   - '2014-01-01T00:00:00.000+00:00'
    *
    * Use of a colon in numeric timezones is optional. However, it is strongly encouraged, for
    * compatibility with Date in major browsers.
    *
    * Parsing is strict, and will throw an error if the input string does not match the expected
    * format. A notable example is that the seconds field must not have more than three decimal
    * places.
    *
    */
    function parseTime_PMILLIS(time_ISO8601: string): number;
    /**
    * Formats a timestamp from posix-millis into the format 'YYYY-MM-DDThh:mm:ss.SSSZZ' (for
    * example '2014-01-01T00:00:00.000Z').
    *
    * The input value is effectively truncated (not rounded!) to milliseconds. So for example,
    * formatTime_ISO8601(12345.999) will return '1970-01-01T00:00:12.345Z' -- exactly the same
    * as for an input of 12345.
    *
    */
    function formatTime_ISO8601(time_PMILLIS: number): string;
}
declare module Webglimpse {
    interface CacheHelper<V> {
        create(key: string): V;
        dispose(value: V, key: string): any;
    }
    class Cache<V> {
        private helper;
        private map;
        constructor(helper: CacheHelper<V>);
        public value(key: string): V;
        public clear(): void;
        public remove(key: string): void;
        public removeAll(keys: string[]): void;
        public retain(key: string): void;
        public retainAll(keys: string[]): void;
        public resetTouches(): void;
        public retainTouched(): void;
    }
}
declare module Webglimpse {
    interface MultiKeyCacheHelper<V> {
        create(keyParts: string[]): V;
        dispose(value: V, keyParts: string[]): any;
    }
    class MultiKeyCache<V> {
        private helper;
        private map;
        constructor(helper: MultiKeyCacheHelper<V>);
        private combineKeyParts(keyParts);
        public value(...keyParts: string[]): V;
        public remove(...keyParts: string[]): void;
        public retain(...keyParts: string[]): void;
        public resetTouches(): void;
        public retainTouched(): void;
        public clear(): void;
    }
    interface TwoKeyCacheHelper<V> {
        create(keyPart1: string, keyPart2: string): V;
        dispose(value: V, keyPart1: string, keyPart2: string): any;
    }
    class TwoKeyCache<V> {
        private cache;
        constructor(helper: TwoKeyCacheHelper<V>);
        public value(keyPart1: string, keyPart2: string): V;
        public remove(keyPart1: string, keyPart2: string): void;
        public retain(keyPart1: string, keyPart2: string): void;
        public resetTouches(): void;
        public retainTouched(): void;
        public clear(): void;
    }
    interface ThreeKeyCacheHelper<V> {
        create(keyPart1: string, keyPart2: string, keyPart3: string): V;
        dispose(value: V, keyPart1: string, keyPart2: string, keyPart3: string): any;
    }
    class ThreeKeyCache<V> {
        private cache;
        constructor(helper: ThreeKeyCacheHelper<V>);
        public value(keyPart1: string, keyPart2: string, keyPart3: string): V;
        public remove(keyPart1: string, keyPart2: string, keyPart3: string): void;
        public retain(keyPart1: string, keyPart2: string, keyPart3: string): void;
        public resetTouches(): void;
        public retainTouched(): void;
        public clear(): void;
    }
}
declare module Webglimpse {
    class BoundsUnmodifiable {
        private bounds;
        constructor(bounds: Bounds);
        public iStart : number;
        public jStart : number;
        public iEnd : number;
        public jEnd : number;
        public i : number;
        public j : number;
        public w : number;
        public h : number;
        public xFrac(i: number): number;
        public yFrac(j: number): number;
        public contains(i: number, j: number): boolean;
    }
    class Bounds {
        private _iStart;
        private _jStart;
        private _iEnd;
        private _jEnd;
        private _unmod;
        constructor();
        public iStart : number;
        public jStart : number;
        public iEnd : number;
        public jEnd : number;
        public i : number;
        public j : number;
        public w : number;
        public h : number;
        public unmod : BoundsUnmodifiable;
        public xFrac(i: number): number;
        public yFrac(j: number): number;
        public contains(i: number, j: number): boolean;
        public setEdges(iStart: number, iEnd: number, jStart: number, jEnd: number): void;
        public setRect(i: number, j: number, w: number, h: number): void;
        public setBounds(bounds: BoundsUnmodifiable): void;
        public cropToEdges(iCropStart: number, iCropEnd: number, jCropStart: number, jCropEnd: number): void;
        public cropToRect(iCrop: number, jCrop: number, wCrop: number, hCrop: number): void;
        public cropToBounds(cropBounds: BoundsUnmodifiable): void;
    }
    function newBoundsFromRect(i: number, j: number, w: number, h: number): Bounds;
    function newBoundsFromEdges(iStart: number, iEnd: number, jStart: number, jEnd: number): Bounds;
    interface Size {
        w: number;
        h: number;
    }
}
declare module Webglimpse {
    class Color {
        private _r;
        private _g;
        private _b;
        private _a;
        public r : number;
        public g : number;
        public b : number;
        public a : number;
        public cssString : string;
        public rgbaString : string;
        constructor(r: number, g: number, b: number, a?: number);
        public withAlphaTimes(aFactor: number): Color;
    }
    function darker(color: Color, factor: number): Color;
    function rgba(r: number, g: number, b: number, a: number): Color;
    function rgb(r: number, g: number, b: number): Color;
    function sameColor(c1: Color, c2: Color): boolean;
    function parseRgba(rgbaString: string): Color;
    /**
    * Creates a Color object based on a CSS color string. Supports the following notations:
    *  - hex
    *  - rgb/rgba
    *  - hsl/hsla
    *  - named colors
    *
    * Behavior is undefined for strings that are not in one of the listed notations.
    *
    * Note that different browsers may use different color values for the named colors.
    *
    */
    var parseCssColor: (cssColorString: string) => Color;
    function gray(brightness: number): Color;
    var black: Color;
    var white: Color;
    var red: Color;
    var green: Color;
    var blue: Color;
    var cyan: Color;
    var magenta: Color;
    var yellow: Color;
    var periwinkle: Color;
}
declare module Webglimpse {
    function glOrtho(left: number, right: number, bottom: number, top: number, near: number, far: number): Float32Array;
    function glOrthoViewport(viewport: BoundsUnmodifiable): Float32Array;
    function glOrthoAxis(axis: Axis2D): Float32Array;
}
declare module Webglimpse {
    class OrderedSet<V> {
        private _idOf;
        private _ids;
        private _indexes;
        private _valuesArray;
        private _valuesMap;
        private _valueAdded;
        private _valueMoved;
        private _valueRemoved;
        constructor(values?: V[], idFn?: IdFunction<V>, useNotifications?: boolean);
        public valueAdded : Notification2<V, number>;
        public valueMoved : Notification3<V, number, number>;
        public valueRemoved : Notification2<V, number>;
        public length : number;
        public isEmpty : boolean;
        public toArray(): V[];
        /**
        * The callback should not modify its array arg; if it does, the subsequent behavior
        * of this OrderedSet is undefined.
        */
        public every(callbackFn: (value: V, index: number, array: V[]) => boolean, thisArg?: any): boolean;
        /**
        * The callback should not modify its array arg; if it does, the subsequent behavior
        * of this OrderedSet is undefined.
        */
        public some(callbackFn: (value: V, index: number, array: V[]) => boolean, thisArg?: any): boolean;
        /**
        * The callback should not modify its array arg; if it does, the subsequent behavior
        * of this OrderedSet is undefined.
        */
        public forEach(callbackFn: (value: V, index: number, array: V[]) => void, thisArg?: any): void;
        /**
        * The callback should not modify its array arg; if it does, the subsequent behavior
        * of this OrderedSet is undefined.
        */
        public map<U>(callbackFn: (value: V, index: number, array: V[]) => U, thisArg?: any): U[];
        /**
        * The callback should not modify its array arg; if it does, the subsequent behavior
        * of this OrderedSet is undefined.
        */
        public filter(callbackFn: (value: V, index: number, array: V[]) => boolean, thisArg?: any): V[];
        /**
        * The callback should not modify its array arg; if it does, the subsequent behavior
        * of this OrderedSet is undefined.
        */
        public reduce<U>(callbackFn: (previousValue: U, currentValue: V, currentIndex: number, array: V[]) => U, initialValue: U): U;
        /**
        * The callback should not modify its array arg; if it does, the subsequent behavior
        * of this OrderedSet is undefined.
        */
        public reduceRight<U>(callbackFn: (previousValue: U, currentValue: V, currentIndex: number, array: V[]) => U, initialValue: U): U;
        public idAt(index: number): string;
        public valueAt(index: number): V;
        public indexFor(id: string): number;
        public valueFor(id: string): V;
        public idOf(value: V): string;
        public indexOf(value: V): number;
        public hasValue(value: V): boolean;
        public hasValues(values: V[]): boolean;
        public hasId(id: string): boolean;
        public hasIds(ids: string[]): boolean;
        public add(value: V, index?: number, moveIfExists?: boolean): void;
        public addAll(values: V[], index?: number, moveIfExists?: boolean): void;
        private _add(value, newIndex, moveIfExists);
        public removeValue(value: V): void;
        public removeId(id: string): void;
        public removeIndex(index: number): void;
        public removeAll(): void;
        public retainValues(values: V[]): void;
        public retainIds(ids: string[]): void;
        public retainIndices(indices: number[]): void;
        private _retain(ids);
        private _remove(id, index);
    }
    class OrderedStringSet {
        private _indexes;
        private _valuesArray;
        private _valueAdded;
        private _valueMoved;
        private _valueRemoved;
        constructor(values?: string[], useNotifications?: boolean);
        public valueAdded : Notification2<string, number>;
        public valueMoved : Notification3<string, number, number>;
        public valueRemoved : Notification2<string, number>;
        public length : number;
        public isEmpty : boolean;
        public toArray(): string[];
        /**
        * The callback should not modify its array arg; if it does, the subsequent behavior
        * of this OrderedStringSet is undefined.
        */
        public every(callbackFn: (value: string, index: number, array: string[]) => boolean, thisArg?: any): boolean;
        /**
        * The callback should not modify its array arg; if it does, the subsequent behavior
        * of this OrderedStringSet is undefined.
        */
        public some(callbackFn: (value: string, index: number, array: string[]) => boolean, thisArg?: any): boolean;
        /**
        * The callback should not modify its array arg; if it does, the subsequent behavior
        * of this OrderedStringSet is undefined.
        */
        public forEach(callbackFn: (value: string, index: number, array: string[]) => void, thisArg?: any): void;
        /**
        * The callback should not modify its array arg; if it does, the subsequent behavior
        * of this OrderedStringSet is undefined.
        */
        public map<U>(callbackFn: (value: string, index: number, array: string[]) => U, thisArg?: any): U[];
        /**
        * The callback should not modify its array arg; if it does, the subsequent behavior
        * of this OrderedStringSet is undefined.
        */
        public filter(callbackFn: (value: string, index: number, array: string[]) => boolean, thisArg?: any): string[];
        /**
        * The callback should not modify its array arg; if it does, the subsequent behavior
        * of this OrderedStringSet is undefined.
        */
        public reduce<U>(callbackFn: (previousValue: U, currentValue: string, currentIndex: number, array: string[]) => U, initialValue: U): U;
        /**
        * The callback should not modify its array arg; if it does, the subsequent behavior
        * of this OrderedStringSet is undefined.
        */
        public reduceRight<U>(callbackFn: (previousValue: U, currentValue: string, currentIndex: number, array: string[]) => U, initialValue: U): U;
        public valueAt(index: number): string;
        public indexOf(value: string): number;
        public hasValue(value: string): boolean;
        public hasValues(values: string[]): boolean;
        public add(value: string, index?: number, moveIfExists?: boolean): void;
        public addAll(values: string[], index?: number, moveIfExists?: boolean): void;
        private _add(value, newIndex, moveIfExists);
        public removeValue(value: string): void;
        public removeIndex(index: number): void;
        public removeAll(): void;
        public retainValues(values: string[]): void;
        public retainIndices(indices: number[]): void;
        private _retain(values);
        private _remove(value, index);
    }
}
declare module Webglimpse {
    interface Listener {
        /**
        * A truthy return value indicates the event was consumed by the listener and no other listeners should be notified
        */
        (): any;
    }
    interface Listener1<A> {
        /**
        * A truthy return value indicates the event was consumed by the listener and no other listeners should be notified
        */
        (a: A): any;
    }
    interface Listener2<A, B> {
        /**
        * A truthy return value indicates the event was consumed by the listener and no other listeners should be notified
        */
        (a: A, b: B): any;
    }
    interface Listener3<A, B, C> {
        /**
        * A truthy return value indicates the event was consumed by the listener and no other listeners should be notified
        */
        (a: A, b: B, c: C): any;
    }
    class Notification {
        private _listeners;
        private _deferring;
        private _deferred;
        public on(listener: Listener): void;
        public off(listener: Listener): void;
        public dispose(): void;
        public fire(): any;
    }
    class Notification1<A> {
        private _listeners;
        private _deferring;
        private _deferred;
        public on(listener: Listener1<A>): void;
        public off(listener: Listener1<A>): void;
        public dispose(): void;
        public fire(a: A): any;
    }
    class Notification2<A, B> {
        private _listeners;
        private _deferring;
        private _deferred;
        public on(listener: Listener2<A, B>): void;
        public off(listener: Listener2<A, B>): void;
        public dispose(): void;
        public fire(a: A, b: B): any;
    }
    class Notification3<A, B, C> {
        private _listeners;
        private _deferring;
        private _deferred;
        public on(listener: Listener3<A, B, C>): void;
        public off(listener: Listener3<A, B, C>): void;
        public dispose(): void;
        public fire(a: A, b: B, c: C): any;
    }
}
declare module Webglimpse {
    function indexOf(vs: number[], x: number): number;
    function indexNearest(vs: number[], x: number): number;
    function indexAfter(vs: number[], x: number): number;
    function indexAtOrAfter(vs: number[], x: number): number;
    function indexBefore(vs: number[], x: number): number;
    function indexAtOrBefore(vs: number[], x: number): number;
}
declare module Webglimpse {
    class BinaryTree<V> {
        private _root;
        private _comp;
        private _size;
        constructor(comparator: Comparator<V>);
        public insert(value: V): void;
        public remove(value: V): void;
        public removeAll(): void;
        public contains(value: V): boolean;
        public getValue(value: V): V;
        public size : number;
        public isEmpty : boolean;
        public ceiling(value: V): V;
        public floor(value: V): V;
        public lower(value: V): V;
        public higher(value: V): V;
        public headSet(value: V, inclusive?: boolean): V[];
        public tailSet(value: V, inclusive?: boolean): V[];
        public subSet(low: V, high: V, lowInclusive?: boolean, highInclusive?: boolean): V[];
        public toArray(): V[];
        public iterator(): Iterator<V>;
        public compare(node1: V, node2: V): number;
        private contains0(value, node);
        private lower0(value, node, inclusive);
        private higher0(value, node, inclusive);
        private sub0(low, high, lowInclusive, highInclusive, node, results);
        private head0(value, inclusive, node, results);
        private tail0(value, inclusive, node, results);
        private addAll0(node, results);
        private remove0(value, node);
        private level0(node);
        private decreaseLevel0(node);
        private insert0(value, node);
        public newTreeNode0(value: V): TreeNode<V>;
        private skew0(node);
        private split0(node);
    }
    class TreeNode<V> {
        private _level;
        private _right;
        private _left;
        private _value;
        constructor(value: V, level?: number, left?: TreeNode<V>, right?: TreeNode<V>);
        public level : number;
        public right : TreeNode<V>;
        public left : TreeNode<V>;
        public value : V;
        public isLeaf(): boolean;
        public getSuccessor(): TreeNode<V>;
        public getPredecessor(): TreeNode<V>;
        public toString(): string;
    }
    interface Iterator<V> {
        hasNext(): boolean;
        next(): V;
    }
    interface Comparator<V> {
        compare(node1: V, node2: V): number;
    }
    class StringComparator implements Comparator<string> {
        public compare(value1: string, value2: string): number;
    }
    class NumberComparator implements Comparator<number> {
        public compare(value1: number, value2: number): number;
    }
    function createStringTree(): BinaryTree<string>;
    function createNumberTree(): BinaryTree<number>;
}
declare module Webglimpse {
    class SortedMultimap<K, V> {
        private _tree;
        private _idFn;
        constructor(comparator: Comparator<K>, idFn?: IdFunction<V>);
        private createContainerComparator<V>(comparator);
        public insert(key: K, value: V): void;
        public remove(key: K, value: V): void;
        public contains(key: K, value: V): boolean;
        public ceiling(key: K): V[];
        public floor(key: K): V[];
        public lower(key: K): V[];
        public higher(key: K): V[];
        public headSet(key: K, inclusive?: boolean): V[];
        public tailSet(key: K, inclusive?: boolean): V[];
        public subSet(low: K, high: K, lowInclusive?: boolean, highInclusive?: boolean): V[];
        public toArray(): V[];
        public iterator(): Iterator<V>;
        private wrap(key);
        private unwrap(values);
        private unwrapArray(values);
    }
    class SortedStringMultimap<K> extends SortedMultimap<K, string> {
        constructor(comparator: Comparator<K>);
    }
}
declare module Webglimpse {
    function initSplitContainer(container: HTMLElement): Notification;
}
declare module Webglimpse {
    interface Buffer {
        bind(gl: WebGLRenderingContext, target: number): any;
        unbind(gl: WebGLRenderingContext, target: number): any;
        dispose(): any;
    }
    interface DynamicBuffer extends Buffer {
        setData(newData: ArrayBuffer): any;
    }
    function newStaticBuffer(data: ArrayBuffer): Buffer;
    function newDynamicBuffer(data?: ArrayBuffer): DynamicBuffer;
}
declare module Webglimpse {
    class Program {
        private vertShaderSource;
        private fragShaderSource;
        private programs;
        constructor(vertShaderSource: string, fragShaderSource: string);
        public _program(gl: WebGLRenderingContext): WebGLProgram;
        public use(gl: WebGLRenderingContext): void;
        public endUse(gl: WebGLRenderingContext): void;
        public dispose(): void;
    }
    class Uniform {
        private program;
        private name;
        private optional;
        private locations;
        constructor(program: Program, name: string, optional: boolean);
        public _location(gl: WebGLRenderingContext): WebGLUniformLocation;
    }
    class Uniform1f extends Uniform {
        constructor(program: Program, name: string, optional?: boolean);
        public setData(gl: WebGLRenderingContext, x: number): void;
    }
    class Uniform2f extends Uniform {
        constructor(program: Program, name: string, optional?: boolean);
        public setData(gl: WebGLRenderingContext, x: number, y: number): void;
    }
    class Uniform3f extends Uniform {
        constructor(program: Program, name: string, optional?: boolean);
        public setData(gl: WebGLRenderingContext, x: number, y: number, z: number): void;
    }
    class Uniform4f extends Uniform {
        constructor(program: Program, name: string, optional?: boolean);
        public setData(gl: WebGLRenderingContext, x: number, y: number, z: number, w: number): void;
    }
    class UniformMatrix4f extends Uniform {
        constructor(program: Program, name: string, optional?: boolean);
        public setData(gl: WebGLRenderingContext, value: Float32Array, transpose?: boolean): void;
    }
    class Uniform1i extends Uniform {
        constructor(program: Program, name: string, optional?: boolean);
        public setData(gl: WebGLRenderingContext, x: number): void;
    }
    class Uniform2i extends Uniform {
        constructor(program: Program, name: string, optional?: boolean);
        public setData(gl: WebGLRenderingContext, x: number, y: number): void;
    }
    class Uniform3i extends Uniform {
        constructor(program: Program, name: string, optional?: boolean);
        public setData(gl: WebGLRenderingContext, x: number, y: number, z: number): void;
    }
    class Uniform4i extends Uniform {
        constructor(program: Program, name: string, optional?: boolean);
        public setData(gl: WebGLRenderingContext, x: number, y: number, z: number, w: number): void;
    }
    class UniformColor extends Uniform {
        constructor(program: Program, name: string, optional?: boolean);
        public setData(gl: WebGLRenderingContext, color: Color): void;
    }
    class UniformSampler2D extends Uniform {
        private currentTexture;
        constructor(program: Program, name: string, optional?: boolean);
        public setDataAndBind(gl: WebGLRenderingContext, textureUnit: number, texture: Texture): void;
        public unbind(gl: WebGLRenderingContext): void;
    }
    class Attribute {
        private program;
        private name;
        private locations;
        constructor(program: Program, name: string);
        public _location(gl: WebGLRenderingContext): number;
        public setDataAndEnable(gl: WebGLRenderingContext, buffer: Buffer, size: number, type: number, normalized?: boolean, stride?: number, offset?: number): void;
        public disable(gl: WebGLRenderingContext): void;
    }
}
declare module Webglimpse {
    interface TextureHelper {
        target(gl: WebGLRenderingContext): number;
        init(gl: WebGLRenderingContext, target: number): any;
    }
    class Texture {
        private helper;
        private textures;
        constructor(helper: TextureHelper);
        public bind(gl: WebGLRenderingContext, textureUnit: number): void;
        public unbind(gl: WebGLRenderingContext): void;
        public dispose(): void;
    }
    interface ImageDrawer {
        (context: CanvasRenderingContext2D): any;
    }
    class FloatDataTexture2D extends Texture {
        private _w;
        private _h;
        public w : number;
        public h : number;
        constructor(w: number, h: number, array: Float32Array);
    }
    class Texture2D extends Texture {
        private _w;
        private _h;
        public w : number;
        public h : number;
        constructor(w: number, h: number, minFilter: number, magFilter: number, draw: ImageDrawer);
    }
    interface TextureDrawOptions {
        xAnchor?: number;
        yAnchor?: number;
        rotation_CCWRAD?: number;
        width?: number;
        height?: number;
    }
    class TextureRenderer {
        private textureRenderer_VERTSHADER;
        private textureRenderer_FRAGSHADER;
        private program;
        private u_XyFrac;
        private u_Anchor;
        private u_Rotation_CCWRAD;
        private u_ImageSize;
        private u_ViewportSize;
        private u_Sampler;
        private a_ImageFrac;
        private imageFracData;
        private wViewport;
        private hViewport;
        constructor();
        public begin(gl: WebGLRenderingContext, viewport: BoundsUnmodifiable): void;
        public draw(gl: WebGLRenderingContext, texture: Texture2D, xFrac: number, yFrac: number, options?: TextureDrawOptions): void;
        public end(gl: WebGLRenderingContext): void;
    }
}
declare module Webglimpse {
    class TextTexture2D extends Texture2D {
        private _jBaseline;
        public jBaseline : number;
        constructor(w: number, h: number, jBaseline: number, minFilter: number, magFilter: number, draw: ImageDrawer);
        public yAnchor(textFrac: number): number;
    }
    function newTextTextureCache(font: string, color: Color): Cache<TextTexture2D>;
    function newTextTextureCache2(font: string): TwoKeyCache<TextTexture2D>;
    function newTextTextureCache3(): ThreeKeyCache<TextTexture2D>;
    interface TextTextureFactory {
        (color: Color, text: string): TextTexture2D;
    }
    function createTextTextureFactory(font: string): TextTextureFactory;
    function newTextHintsCache(font: string): Cache<Texture2D>;
    class HintedTextRenderer {
        private textRenderer_VERTSHADER;
        private textRenderer_FRAGSHADER;
        private program;
        private u_XyFrac;
        private u_Anchor;
        private u_ImageSize;
        private u_ViewportSize;
        private u_Alpha;
        private u_Hints;
        private a_ImageFrac;
        private imageFracData;
        private wViewport;
        private hViewport;
        constructor();
        public begin(gl: WebGLRenderingContext, viewport: BoundsUnmodifiable): void;
        public draw(gl: WebGLRenderingContext, hints: Texture2D, xFrac: number, yFrac: number, options?: {
            xAnchor?: number;
            yAnchor?: number;
            color?: Color;
        }): void;
        public end(gl: WebGLRenderingContext): void;
    }
}
declare module Webglimpse {
    interface Painter {
        (gl: WebGLRenderingContext, viewport: BoundsUnmodifiable): any;
    }
    interface PointerEvent {
        paneViewport: BoundsUnmodifiable;
        i: number;
        j: number;
        wheelSteps?: number;
        clickCount?: number;
        mouseEvent?: MouseEvent;
    }
    function xFrac(ev: PointerEvent): number;
    function yFrac(ev: PointerEvent): number;
    interface LayoutEntry {
        layoutArg: any;
        layoutOptions: any;
        viewport: Bounds;
        prefSize: Size;
    }
    interface LayoutPhase1 {
        (parentPrefSize: Size, children: LayoutEntry[]): any;
    }
    interface LayoutPhase2 {
        (children: LayoutEntry[], parentViewport: BoundsUnmodifiable): any;
    }
    interface Layout {
        updatePrefSize?: LayoutPhase1;
        updateChildViewports?: LayoutPhase2;
    }
    interface Mask2D {
        (viewport: BoundsUnmodifiable, i: number, j: number): boolean;
    }
    class Pane {
        private painters;
        private consumesInputEvents;
        private isInside;
        private _mouseCursor;
        private _mouseCursorChanged;
        private _childMouseCursorListener;
        private children;
        private _layout;
        private _viewport;
        private _scissor;
        private _viewportChanged;
        private _dispose;
        constructor(layout: Layout, consumesInputEvents?: boolean, isInside?: Mask2D);
        public layout : Layout;
        public mouseCursor : string;
        public mouseCursorChanged : Notification;
        public addPainter(painter: Painter): void;
        public addPane(pane: Pane, layoutArg?: any, layoutOptions?: any): void;
        public removePane(pane: Pane): void;
        public layoutArg(pane: Pane): any;
        public setLayoutArg(pane: Pane, layoutArg: any): void;
        public updateLayoutArgs(updateFn: (layoutArg: any, layoutOptions: any) => any): void;
        public layoutOptions(pane: Pane): any;
        private _childFor(pane);
        public updatePrefSizes(result: Size): void;
        public updateBounds(viewport: BoundsUnmodifiable, scissor: BoundsUnmodifiable): void;
        public paint(gl: WebGLRenderingContext): void;
        public viewport : BoundsUnmodifiable;
        public scissor : BoundsUnmodifiable;
        public viewportChanged : Notification;
        public panesAt(i: number, j: number): Pane[];
        private _panesAt(i, j, result);
        private _mouseUp;
        private _mouseDown;
        private _mouseMove;
        private _mouseWheel;
        private _mouseEnter;
        private _mouseExit;
        private _contextMenu;
        public mouseUp : Notification1<PointerEvent>;
        public mouseDown : Notification1<PointerEvent>;
        public mouseMove : Notification1<PointerEvent>;
        public mouseWheel : Notification1<PointerEvent>;
        public mouseEnter : Notification1<PointerEvent>;
        public mouseExit : Notification1<PointerEvent>;
        public contextMenu : Notification1<PointerEvent>;
        public fireMouseUp(i: number, j: number, clickCount: number, mouseEvent: MouseEvent): any;
        public fireMouseDown(i: number, j: number, clickCount: number, mouseEvent: MouseEvent): any;
        public fireMouseMove(i: number, j: number, mouseEvent: MouseEvent): any;
        public fireMouseWheel(i: number, j: number, wheelSteps: number, mouseEvent: MouseEvent): any;
        public fireMouseEnter(i: number, j: number, mouseEvent: MouseEvent): any;
        public fireMouseExit(i: number, j: number, mouseEvent: MouseEvent): any;
        public fireContextMenu(i: number, j: number, mouseEvent: MouseEvent): any;
        public dispose : Notification;
    }
    function requireGL(canvasElement: HTMLCanvasElement): WebGLRenderingContext;
    function isLeftMouseDown(ev: MouseEvent): boolean;
    function isMouseDown(ev: MouseEvent): boolean;
    interface Drawable {
        setContentPane(pane: Pane): any;
        redraw(): any;
        getPrefSize(): Size;
        prefSizeChanged(): Notification1<Size>;
    }
    function newDrawable(canvas: HTMLCanvasElement): Drawable;
}
declare module Webglimpse {
    function newGroupPainter(...painters: Painter[]): Painter;
    function newBlendingBackgroundPainter(color: Color): Painter;
    class Background {
        private _color;
        constructor(color?: Color);
        public color : Color;
        public newPainter(): (gl: WebGLRenderingContext, viewport: BoundsUnmodifiable) => void;
    }
    function newBackgroundPainter(color: Color): Painter;
    function newTexturePainter(texture: Texture2D, xFrac: number, yFrac: number, options: TextureDrawOptions): (gl: WebGLRenderingContext, viewport: BoundsUnmodifiable) => void;
    function newSolidPane(color: Color): Pane;
    function fitToTexture(texture: Texture2D): (parentPrefSize: Size) => void;
    function fixedSize(w: number, h: number): (parentPrefSize: Size) => void;
    /**
    * Takes (x,y) in NDC (Normalized Device Coords), in attribute a_XyNdc
    */
    var xyNdc_VERTSHADER: string;
    /**
    * Takes (x,y) as fractions of the viewport, in attribute a_XyFrac
    */
    var xyFrac_VERTSHADER: string;
    var solid_FRAGSHADER: string;
    var varyingColor_FRAGSHADER: string;
    var modelview_VERTSHADER: string;
    var nearestPixelCenter_GLSLFUNC: string;
    enum Side {
        TOP = 0,
        BOTTOM = 1,
        RIGHT = 2,
        LEFT = 3,
    }
    /**
    * Converts viewport-fraction to NDC (Normalized Device Coords)
    */
    function fracToNdc(frac: number): number;
    function nearestPixel(viewportFrac: number, viewportSize: number, imageAnchor: number, imageSize: number): number;
    function putQuadXys(xys: Float32Array, index: number, xLeft: number, xRight: number, yTop: number, yBottom: number): number;
    function putUpperLeftTriangleXys(xys: Float32Array, index: number, xLeft: number, xRight: number, yTop: number, yBottom: number): number;
    function putLowerRightTriangleXys(xys: Float32Array, index: number, xLeft: number, xRight: number, yTop: number, yBottom: number): number;
    function putUpperRightTriangleXys(xys: Float32Array, index: number, xLeft: number, xRight: number, yTop: number, yBottom: number): number;
    function putLowerLeftTriangleXys(xys: Float32Array, index: number, xLeft: number, xRight: number, yTop: number, yBottom: number): number;
    function putQuadRgbas(rgbas: Float32Array, index: number, color: Color): number;
    function putRgbas(rgbas: Float32Array, index: number, color: Color, count: number): number;
    function clearSelection(): void;
    class SimpleModel<V> {
        private _value;
        private _changed;
        constructor(value?: V);
        public value : V;
        public changed : Notification;
    }
    class XyModel {
        private _x;
        private _y;
        private _changed;
        constructor(x?: number, y?: number);
        public x : number;
        public y : number;
        public changed : Notification;
        public setXy(x: number, y: number): void;
    }
}
declare module Webglimpse {
    class Label {
        private _font;
        private _fgColor;
        private _bgColor;
        private _text;
        private _textureFactory;
        private _texture;
        constructor(text?: string, font?: string, fgColor?: Color, bgColor?: Color);
        public font : string;
        public color : Color;
        public fgColor : Color;
        public bgColor : Color;
        public text : string;
        public texture : TextTexture2D;
    }
    function fitToLabel(label: Label): (parentPrefSize: Size) => void;
    function newLabelPainter(label: Label, xFrac: number, yFrac: number, xAnchor?: number, yAnchor?: number, rotation_CCWRAD?: number): (gl: WebGLRenderingContext, viewport: BoundsUnmodifiable) => void;
}
declare module Webglimpse {
    interface VerticalScrollLayout extends Layout {
        jOffset: number;
        hContent: number;
        hVisible: number;
    }
    function newVerticalScrollLayout(): VerticalScrollLayout;
    interface ScrollbarOptions {
        fgColor?: Color;
        bgColor?: Color;
        borderColor?: Color;
        borderThickness?: number;
        borderTop?: boolean;
        borderLeft?: boolean;
        borderRight?: boolean;
        borderBottom?: boolean;
    }
    function newVerticalScrollbar(scrollLayout: VerticalScrollLayout, drawable: Drawable, options?: ScrollbarOptions): Pane;
    function newVerticalScrollbarPainter(scrollLayout: VerticalScrollLayout, options?: ScrollbarOptions): Painter;
    function attachTimelineVerticalScrollMouseListeners(pane: Pane, scrollLayout: VerticalScrollLayout, drawable: Drawable): void;
    function attachVerticalScrollMouseListeners(scrollbar: Pane, scrollLayout: VerticalScrollLayout, drawable: Drawable): void;
}
declare module Webglimpse {
    interface Insets {
        top: number;
        right: number;
        bottom: number;
        left: number;
    }
    function newInsets(...insets: number[]): Insets;
    function newInsetLayout(insets: Insets): Layout;
    function newInsetPane(pane: Pane, insets: Insets, bgColor?: Color, consumeInputEvents?: boolean): Pane;
}
declare module Webglimpse {
    function newCornerLayout(hSide: Side, vSide: Side): Layout;
}
declare module Webglimpse {
    function newRowLayout(topToBottom?: boolean): Layout;
}
declare module Webglimpse {
    function newColumnLayout(leftToRight?: boolean): Layout;
}
declare module Webglimpse {
    /**
    * Simple layout which sets the sizes of all child panes to the size of the parent pane
    * (causing all the children to 'overlay' each other and the parent).
    */
    function newOverlayLayout(): Layout;
}
declare module Webglimpse {
    /**
    * A layout similar to overlay_layout except only one child pane is visible at a time.
    * That child pane has its size set to the size of the parent pane. The other children panes
    * are made invisible until they are the active pane.
    *
    * The layoutArg for each child is a boolean, true if it should be the active pane. One is chosen
    * arbitrarily if multiple panes have true layoutArg.
    */
    function newCardLayout(): Layout;
}
declare module Webglimpse {
    interface BorderOptions {
        drawTop?: boolean;
        drawLeft?: boolean;
        drawRight?: boolean;
        drawBottom?: boolean;
        thickness?: number;
    }
    function newBorderPainter(color: Color, options?: BorderOptions): Painter;
}
declare module Webglimpse {
    class Axis1D {
        private _vMin;
        private _vMax;
        private _limitsChanged;
        constructor(vMin: number, vMax: number);
        public vMin : number;
        public vMax : number;
        public limitsChanged : Notification;
        public setVRange(vMin: number, vMax: number): void;
        public vSize : number;
        public vAtFrac(vFrac: number): number;
        public vFrac(v: number): number;
        public pan(vAmount: number): void;
        public zoom(factor: number, vAnchor: number): void;
    }
    function getTickInterval(axis: Axis1D, approxNumTicks: number): number;
    function getTickCount(axis: Axis1D, tickInterval: number): number;
    function getTickPositions(axis: Axis1D, tickInterval: number, tickCount: number, result: Float32Array): void;
    class Axis2D {
        private _xAxis;
        private _yAxis;
        public xAxis : Axis1D;
        public xMin : number;
        public xMax : number;
        public xAtFrac(xFrac: number): number;
        public yAxis : Axis1D;
        public yMin : number;
        public yMax : number;
        public yAtFrac(yFrac: number): number;
        constructor(xAxis: Axis1D, yAxis: Axis1D);
        public onLimitsChanged(listener: Listener): void;
        public pan(xAmount: number, yAmount: number): void;
        public zoom(factor: number, xAnchor: number, yAnchor: number): void;
    }
    function newAxis2D(xMin: number, xMax: number, yMin: number, yMax: number): Axis2D;
    var axisZoomStep: number;
    function attachAxisMouseListeners1D(pane: Pane, axis: Axis1D, isVertical: boolean): void;
    function attachAxisMouseListeners2D(pane: Pane, axis: Axis2D): void;
}
declare module Webglimpse {
    function newPlotLayout(options?: {
        horizAxisHeight?: number;
        vertAxisWidth?: number;
    }): Layout;
}
declare module Webglimpse {
    function edgeMarks_VERTSHADER(labelSide: Side): string;
    var gradient_FRAGSHADER: string;
    interface TickLabeler {
        (value: number, axis: Axis1D, tickInterval: number): string;
    }
    interface EdgeAxisPainterOptions {
        tickSpacing?: number;
        label?: string;
        units?: string;
        shortenLabels?: boolean;
        font?: string;
        textColor?: Color;
        tickColor?: Color;
        tickSize?: number;
        showLabel?: boolean;
        showBorder?: boolean;
        gradientFill?: Gradient;
        tickLabeler?: TickLabeler;
    }
    function newEdgeAxisPainter(axis: Axis1D, labelSide: Side, options?: EdgeAxisPainterOptions): Painter;
}
declare module Webglimpse {
    interface XyLinePainterOptions {
        color?: Color;
        blend?: boolean;
        thickness?: number;
    }
    /**
    * Simple xy line painter which displays static data
    */
    function newXyLinePainter(axis: Axis2D, xCoords: number[], yCoords: number[], options?: XyLinePainterOptions): Painter;
}
declare module Webglimpse {
    interface Gradient {
        (value: number): number[];
    }
    function jet(value: number): number[];
    function reverseBone(value: number): number[];
    function getGradientTexture(gradient: Gradient, size?: number): Texture;
}
declare module Webglimpse {
    interface HeatmapPainterOptions {
        blend?: boolean;
    }
    interface HeatMapData {
        array: Float32Array;
        xSize: number;
        ySize: number;
        xMin: number;
        xMax: number;
        yMin: number;
        yMax: number;
    }
    var heatmap_VERTSHADER: string;
    var heatmap_FRAGSHADER: string;
    /**
    * Simple heatmap painter which displays a 2d matrix of static data
    */
    function newHeatmapPainter(axis: Axis2D, colorAxis: Axis1D, data: HeatMapData, colorTexture: Texture, options?: HeatmapPainterOptions): Painter;
}
declare module Webglimpse {
    function secondsToMillis(value_SECONDS: number): number;
    function millisToSeconds(value_MILLIS: number): number;
    function minutesToMillis(value_MINUTES: number): number;
    function millisToMinutes(value_MILLIS: number): number;
    function hoursToMillis(value_HOURS: number): number;
    function millisToHours(value_MILLIS: number): number;
    function daysToMillis(value_DAYS: number): number;
    function millisToDays(value_MILLIS: number): number;
}
declare module Webglimpse {
    class TimeAxis1D extends Axis1D {
        private _epoch_PMILLIS;
        constructor(tMin_PMILLIS: number, tMax_PMILLIS: number);
        public tMin_PMILLIS : number;
        public tMax_PMILLIS : number;
        public setTRange_PMILLIS(tMin_PMILLIS: number, tMax_PMILLIS: number): void;
        public tSize_MILLIS : number;
        public vAtTime(t_PMILLIS: number): number;
        public tAtFrac_PMILLIS(tFrac: number): number;
        public tFrac(t_PMILLIS: number): number;
        public tPan(tAmount_MILLIS: number): void;
        public tZoom(factor: number, tAnchor_PMILLIS: number): void;
    }
}
declare module Webglimpse {
    interface TimeAxisPainterOptions {
        tickSpacing?: number;
        font?: string;
        textColor?: Color;
        tickColor?: Color;
        tickSize?: number;
        labelAlign?: number;
        referenceDate?: string;
        isFuturePositive?: boolean;
    }
    function newTimeAxisPainter(timeAxis: TimeAxis1D, labelSide: Side, displayTimeZone: string, tickTimeZone: string, options?: TimeAxisPainterOptions): Painter;
    function getTickTimes_PMILLIS(timeAxis: TimeAxis1D, sizePixels: number, tickSpacing: number, timeZone: string, referenceDate_PMILLIS: number): number[];
}
declare module Webglimpse {
    interface TimeGridPainterOptions {
        tickSpacing?: number;
        gridColor?: Color;
        referenceDate?: string;
    }
    function newTimeGridPainter(timeAxis: TimeAxis1D, isVerticalAxis: boolean, timeZone: string, options?: TimeGridPainterOptions): Painter;
}
declare module Webglimpse {
    interface TimelineCursor {
        cursorGuid: string;
        labeledTimeseriesGuids: string[];
        lineColor: string;
        textColor: string;
        showVerticalLine: boolean;
        showHorizontalLine: boolean;
        showCursorText: boolean;
    }
    interface TimelineAnnotation {
        annotationGuid: string;
        time_ISO8601?: string;
        y?: number;
        label: string;
        styleGuid: string;
    }
    interface TimelineTimeseries {
        timeseriesGuid: string;
        uiHint?: string;
        baseline?: number;
        lineColor?: string;
        pointColor?: string;
        lineThickness?: number;
        pointSize?: number;
        fragmentGuids?: string[];
    }
    interface TimelineTimeseriesFragment {
        fragmentGuid: string;
        data?: number[];
        times_ISO8601?: string[];
        userEditMode?: string;
    }
    interface TimelineEvent {
        eventGuid: string;
        start_ISO8601: string;
        end_ISO8601: string;
        label: string;
        startLimit_ISO8601?: string;
        endLimit_ISO8601?: string;
        labelIcon?: string;
        userEditable?: boolean;
        styleGuid?: string;
        order?: number;
        topMargin?: number;
        bottomMargin?: number;
        fgColor?: string;
        bgColor?: string;
        bgSecondaryColor?: string;
        borderColor?: string;
        borderSecondaryColor?: string;
        labelTopMargin?: number;
        labelBottomMargin?: number;
        labelVAlign?: number;
        labelVPos?: number;
        labelHAlign?: number;
        labelHPos?: number;
        isBorderDashed?: boolean;
        fillPattern?: string;
    }
    interface TimelineRow {
        rowGuid: string;
        label: string;
        hidden?: boolean;
        rowHeight?: number;
        yMin?: number;
        yMax?: number;
        uiHint?: string;
        eventGuids?: string[];
        timeseriesGuids?: string[];
        annotationGuids?: string[];
        cursorGuid?: string;
        bgColor?: string;
        fgLabelColor?: string;
        bgLabelColor?: string;
        labelFont?: string;
    }
    interface TimelineGroup {
        groupGuid: string;
        rollupGuid?: string;
        label: string;
        hidden?: boolean;
        collapsed?: boolean;
        rowGuids: string[];
    }
    interface TimelineRoot {
        groupGuids: string[];
        topPinnedRowGuids: string[];
        bottomPinnedRowGuids: string[];
        maximizedRowGuids: string[];
    }
    interface Timeline {
        cursors: TimelineCursor[];
        annotations: TimelineAnnotation[];
        timeseriesFragments: TimelineTimeseriesFragment[];
        timeseries: TimelineTimeseries[];
        events: TimelineEvent[];
        rows: TimelineRow[];
        groups: TimelineGroup[];
        root: TimelineRoot;
    }
    class TimelineCursorModel {
        private _cursorGuid;
        private _labeledTimeseriesGuids;
        private _lineColor;
        private _textColor;
        private _showCursorText;
        private _showVerticalLine;
        private _showHorizontalLine;
        private _attrsChanged;
        constructor(cursor: TimelineCursor);
        public labeledTimeseriesGuids : OrderedStringSet;
        public cursorGuid : string;
        public attrsChanged : Notification;
        public lineColor : Color;
        public textColor : Color;
        public showVerticalLine : boolean;
        public showHorizontalLine : boolean;
        public showCursorText : boolean;
        public setAttrs(cursor: TimelineCursor): void;
        public snapshot(): TimelineCursor;
    }
    class TimelineAnnotationModel {
        private _annotationGuid;
        private _attrsChanged;
        private _time_PMILLIS;
        private _y;
        private _label;
        private _styleGuid;
        constructor(annotation: TimelineAnnotation);
        public annotationGuid : string;
        public attrsChanged : Notification;
        public setLocation(time_PMILLIS: number, y: number): void;
        public time_PMILLIS : number;
        public y : number;
        public label : string;
        public styleGuid : string;
        public setAttrs(annotation: TimelineAnnotation): void;
        public snapshot(): TimelineAnnotation;
    }
    class TimelineTimeseriesModel {
        private _timeseriesGuid;
        private _attrsChanged;
        private _uiHint;
        private _baseline;
        private _lineColor;
        private _pointColor;
        private _lineThickness;
        private _pointSize;
        private _fragmentGuids;
        constructor(timeseries: TimelineTimeseries);
        public timeseriesGuid : string;
        public attrsChanged : Notification;
        public setAttrs(timeseries: TimelineTimeseries): void;
        public baseline : number;
        public lineColor : Color;
        public pointColor : Color;
        public lineThickness : number;
        public pointSize : number;
        public uiHint : string;
        public fragmentGuids : OrderedStringSet;
        public snapshot(): TimelineTimeseries;
    }
    class TimelineTimeseriesFragmentModel {
        private _fragmentGuid;
        private _dataChanged;
        private _attrsChanged;
        private _userEditMode;
        private _data;
        private _times_PMILLIS;
        constructor(fragment: TimelineTimeseriesFragment);
        public fragmentGuid : string;
        public dataChanged : Notification2<number, number>;
        public setAttrs(fragment: TimelineTimeseriesFragment): void;
        public data : number[];
        public times_PMILLIS : number[];
        public setAllData(data: number[], times_PMILLIS: number[]): void;
        public setData(index: number, value: number, time?: number): number;
        public start_PMILLIS : number;
        public end_PMILLIS : number;
        public userEditMode : string;
        public snapshot(): TimelineTimeseriesFragment;
    }
    class TimelineEventModel {
        private _eventGuid;
        private _attrsChanged;
        private _startLimit_PMILLIS;
        private _endLimit_PMILLIS;
        private _start_PMILLIS;
        private _end_PMILLIS;
        private _label;
        private _labelIcon;
        private _userEditable;
        private _styleGuid;
        private _order;
        private _topMargin;
        private _bottomMargin;
        private _fgColor;
        private _bgColor;
        private _bgSecondaryColor;
        private _borderColor;
        private _borderSecondaryColor;
        private _labelTopMargin;
        private _labelBottomMargin;
        private _labelVAlign;
        private _labelVPos;
        private _labelHAlign;
        private _labelHPos;
        private _isBorderDashed;
        private _fillPattern;
        constructor(event: TimelineEvent);
        public eventGuid : string;
        public attrsChanged : Notification;
        public setAttrs(event: TimelineEvent): void;
        public setInterval(start_PMILLIS: number, end_PMILLIS: number): void;
        private limit_start_PMILLIS(start_PMILLIS);
        private limit_end_PMILLIS(end_PMILLIS);
        public start_PMILLIS : number;
        public end_PMILLIS : number;
        public startLimit_PMILLIS : number;
        public endLimit_PMILLIS : number;
        public label : string;
        public labelIcon : string;
        public userEditable : boolean;
        public styleGuid : string;
        public order : number;
        public topMargin : number;
        public bottomMargin : number;
        public fgColor : Color;
        public bgColor : Color;
        public bgSecondaryColor : Color;
        public borderColor : Color;
        public borderSecondaryColor : Color;
        public labelTopMargin : number;
        public labelBottomMargin : number;
        public labelVAlign : number;
        public labelVPos : number;
        public labelHAlign : number;
        public labelHPos : number;
        public isBorderDashed : boolean;
        public fillPattern : FillPattern;
        public snapshot(): TimelineEvent;
    }
    class TimelineRowModel {
        private _rowGuid;
        private _attrsChanged;
        private _rowHeight;
        private _hidden;
        private _label;
        private _uiHint;
        private _eventGuids;
        private _timeseriesGuids;
        private _annotationGuids;
        private _cursorGuid;
        private _bgColor;
        private _fgLabelColor;
        private _bgLabelColor;
        private _labelFont;
        private _dataAxis;
        constructor(row: TimelineRow);
        public rowGuid : string;
        public attrsChanged : Notification;
        public setAttrs(row: TimelineRow): void;
        public cursorGuid : string;
        public rowHeight : number;
        public hidden : boolean;
        public dataAxis : Axis1D;
        public label : string;
        public uiHint : string;
        public bgColor : Color;
        public bgLabelColor : Color;
        public fgLabelColor : Color;
        public labelFont : string;
        public eventGuids : OrderedStringSet;
        public timeseriesGuids : OrderedStringSet;
        public annotationGuids : OrderedStringSet;
        public snapshot(): TimelineRow;
    }
    class TimelineGroupModel {
        private _groupGuid;
        private _rollupGuid;
        private _attrsChanged;
        private _hidden;
        private _label;
        private _collapsed;
        private _rowGuids;
        constructor(group: TimelineGroup);
        public groupGuid : string;
        public rollupGuid : string;
        public attrsChanged : Notification;
        public setAttrs(group: TimelineGroup): void;
        public hidden : boolean;
        public label : string;
        public collapsed : boolean;
        public rowGuids : OrderedStringSet;
        public snapshot(): TimelineGroup;
    }
    class TimelineRootModel {
        private _attrsChanged;
        private _groupGuids;
        private _topPinnedRowGuids;
        private _bottomPinnedRowGuids;
        private _maximizedRowGuids;
        constructor(root: TimelineRoot);
        public attrsChanged : Notification;
        public setAttrs(root: TimelineRoot): void;
        public groupGuids : OrderedStringSet;
        public topPinnedRowGuids : OrderedStringSet;
        public bottomPinnedRowGuids : OrderedStringSet;
        public maximizedRowGuids : OrderedStringSet;
        public snapshot(): TimelineRoot;
    }
    interface TimelineMergeStrategy {
        updateCursorModel(cursorModel: TimelineCursorModel, newCursor: TimelineCursor): any;
        updateAnnotationModel(annotationModel: TimelineAnnotationModel, newAnnotation: TimelineAnnotation): any;
        updateTimeseriesFragmentModel(timeseriesFragmentModel: TimelineTimeseriesFragmentModel, newTimeseriesFragment: TimelineTimeseriesFragment): any;
        updateTimeseriesModel(timeseriesModel: TimelineTimeseriesModel, newTimeseries: TimelineTimeseries): any;
        updateEventModel(eventModel: TimelineEventModel, newEvent: TimelineEvent): any;
        updateRowModel(rowModel: TimelineRowModel, newRow: TimelineRow): any;
        updateGroupModel(groupModel: TimelineGroupModel, newGroup: TimelineGroup): any;
        updateRootModel(rootModel: TimelineRootModel, newRoot: TimelineRoot): any;
    }
    class TimelineModel {
        private _cursors;
        private _annotations;
        private _timeseriesFragments;
        private _timeseries;
        private _events;
        private _rows;
        private _groups;
        private _root;
        constructor(timeline?: Timeline);
        public cursors : OrderedSet<TimelineCursorModel>;
        public annotations : OrderedSet<TimelineAnnotationModel>;
        public timeseriesFragments : OrderedSet<TimelineTimeseriesFragmentModel>;
        public timeseriesSets : OrderedSet<TimelineTimeseriesModel>;
        public events : OrderedSet<TimelineEventModel>;
        public rows : OrderedSet<TimelineRowModel>;
        public groups : OrderedSet<TimelineGroupModel>;
        public root : TimelineRootModel;
        public cursor(cursorGuid: string): TimelineCursorModel;
        public annotation(annotationGuid: string): TimelineAnnotationModel;
        public timeseriesFragment(fragmentGuid: string): TimelineTimeseriesFragmentModel;
        public timeseries(timeseriesGuid: string): TimelineTimeseriesModel;
        public event(eventGuid: string): TimelineEventModel;
        public row(rowGuid: string): TimelineRowModel;
        public group(groupGuid: string): TimelineGroupModel;
        public replace(newTimeline: Timeline): void;
        public merge(newData: Timeline, strategy: TimelineMergeStrategy): void;
        public snapshot(): Timeline;
    }
    function newEmptyTimelineRoot(): TimelineRoot;
    var timelineMergeNewBeforeOld: TimelineMergeStrategy;
    var timelineMergeNewAfterOld: TimelineMergeStrategy;
}
declare module Webglimpse {
    function newTimelineLayout(axisHeight: number): Layout;
}
declare module Webglimpse {
    interface TimeseriesCursorPainterOptions {
        font?: string;
        textColor?: Color;
        buffer_px?: number;
        textDecimals?: number;
        lineColor?: Color;
        crosshairThickness_px?: number;
        boxSize_px?: number;
        boxThickness_px?: number;
    }
    function newTimeseriesCursorPainterFactory(cursorOptions?: TimeseriesCursorPainterOptions): TimelineTimeseriesPainterFactory;
}
declare module Webglimpse {
    function newTimeseriesAnnotationPainterFactory(): TimelineTimeseriesPainterFactory;
}
declare module Webglimpse {
    interface TimelineAnnotationIcon {
        url: string;
        displayWidth: number;
        displayHeight: number;
        hAlign: number;
        vAlign: number;
        hOffset: number;
        vOffset: number;
    }
    interface TimelineAnnotationStyle {
        styleGuid: string;
        color?: string;
        font?: string;
        hTextAlign?: number;
        vTextAlign?: number;
        hTextOffset?: number;
        vTextOffset?: number;
        align?: number;
        uiHint?: string;
        icons?: TimelineAnnotationIcon[];
    }
    class TimelineAnnotationIconUi {
        private _url;
        private _displayWidth;
        private _displayHeight;
        private _hAlign;
        private _vAlign;
        private _hOffset;
        private _vOffset;
        constructor(icon: TimelineAnnotationIcon);
        private _setAttrs(icon);
        public url : string;
        public displayWidth : number;
        public displayHeight : number;
        public hAlign : number;
        public vAlign : number;
        public hOffset : number;
        public vOffset : number;
        public snapshot(): TimelineAnnotationIcon;
    }
    class TimelineAnnotationStyleUi {
        private _styleGuid;
        private _color;
        private _font;
        private _vTextOffset;
        private _hTextOffset;
        private _vTextAlign;
        private _hTextAlign;
        private _align;
        private _uiHint;
        private _icons;
        constructor(style: TimelineAnnotationStyle);
        public styleGuid : string;
        private _setAttrs(style);
        public numIcons : number;
        public icon(index: number): TimelineAnnotationIconUi;
        public color : Color;
        public font : string;
        public hTextOffset : number;
        public vTextOffset : number;
        public hTextAlign : number;
        public vTextAlign : number;
        public align : number;
        public uiHint : string;
        public snapshot(): TimelineAnnotationStyle;
    }
}
declare module Webglimpse {
    interface TimelineEventIcon {
        url: string;
        displayWidth: number;
        displayHeight: number;
        hAlign: number;
        hPos: number;
    }
    interface TimelineEventStyle {
        styleGuid: string;
        icons: TimelineEventIcon[];
    }
    class TimelineEventIconUi {
        private _url;
        private _displayWidth;
        private _displayHeight;
        private _hAlign;
        private _hPos;
        constructor(icon: TimelineEventIcon);
        private _setAttrs(icon);
        public url : string;
        public displayWidth : number;
        public displayHeight : number;
        public hAlign : number;
        public hPos : number;
        public snapshot(): TimelineEventIcon;
    }
    class TimelineEventStyleUi {
        private _styleGuid;
        private _icons;
        constructor(style: TimelineEventStyle);
        public styleGuid : string;
        private _setAttrs(style);
        public numIcons : number;
        public icon(index: number): TimelineEventIconUi;
        public snapshot(): TimelineEventStyle;
    }
}
declare module Webglimpse {
    interface TimelineUiOptions {
        allowEventMultiSelection?: boolean;
    }
    class TimelineUi {
        private _input;
        private _selection;
        private _groupUis;
        private _rowUis;
        private _eventStyles;
        private _annotationStyles;
        private _millisPerPx;
        private _imageStatus;
        private _imageCache;
        private _dispose;
        private _panes;
        constructor(model: TimelineModel, options?: TimelineUiOptions);
        public input : TimelineInput;
        public selection : TimelineSelectionModel;
        public groupUis : OrderedSet<TimelineGroupUi>;
        public groupUi(groupGuid: string): TimelineGroupUi;
        public rowUis : OrderedSet<TimelineRowUi>;
        public rowUi(rowGuid: string): TimelineRowUi;
        public eventStyles : OrderedSet<TimelineEventStyleUi>;
        public eventStyle(styleGuid: string): TimelineEventStyleUi;
        public annotationStyles : OrderedSet<TimelineAnnotationStyleUi>;
        public annotationStyle(styleGuid: string): TimelineAnnotationStyleUi;
        public millisPerPx : SimpleModel<number>;
        public loadImage(url: string, onLoaded: () => void): Texture2D;
        public panes : OrderedSet<Pane>;
        public addPane(paneId: string, pane: Pane): void;
        public removePane(paneId: string): void;
        public getPane(paneId: string): Pane;
        public dispose : Notification;
    }
    class TimelineGroupUi {
        private _groupGuid;
        constructor(groupGuid: string);
        public groupGuid : string;
    }
    class TimelineRowUi {
        private _rowGuid;
        private _paneFactoryChanged;
        private _paneFactory;
        private _panes;
        constructor(rowGuid: string);
        public rowGuid : string;
        public paneFactoryChanged : Notification;
        public paneFactory : TimelineRowPaneFactory;
        public panes : OrderedSet<Pane>;
        public addPane(paneId: string, pane: Pane): void;
        public removePane(paneId: string): void;
        public getPane(paneId: string): Pane;
    }
    class TimelineInput {
        private _mouseMove;
        private _mouseExit;
        private _timeHover;
        private _rowHover;
        private _eventHover;
        private _mouseDown;
        private _mouseUp;
        private _contextMenu;
        public mouseMove : Notification1<PointerEvent>;
        public mouseExit : Notification1<PointerEvent>;
        public timeHover : Notification2<number, PointerEvent>;
        public rowHover : Notification2<TimelineRowModel, PointerEvent>;
        public eventHover : Notification2<TimelineEventModel, PointerEvent>;
        public mouseDown : Notification1<PointerEvent>;
        public mouseUp : Notification1<PointerEvent>;
        public contextMenu : Notification1<PointerEvent>;
    }
    class TimelineSelectionModel {
        private _mousePos;
        private _hoveredY;
        private _hoveredTime_PMILLIS;
        private _selectedInterval;
        private _hoveredRow;
        private _hoveredEvent;
        private _selectedEvents;
        private _hoveredTimeseries;
        private _hoveredAnnotation;
        public mousePos : XyModel;
        public hoveredY : SimpleModel<number>;
        public hoveredTime_PMILLIS : SimpleModel<number>;
        public selectedInterval : TimeIntervalModel;
        public hoveredRow : SimpleModel<TimelineRowModel>;
        public hoveredEvent : SimpleModel<TimelineEventModel>;
        public selectedEvents : OrderedSet<TimelineEventModel>;
        public hoveredTimeseries : TimelineTimeseriesFragmentSelectionModel;
        public hoveredAnnotation : SimpleModel<TimelineAnnotationModel>;
    }
    class TimelineTimeseriesFragmentSelectionModel {
        private _fragment;
        private _index;
        private _changed;
        constructor(fragment?: TimelineTimeseriesFragmentModel, index?: number);
        public setValue(fragment: TimelineTimeseriesFragmentModel, index: number): void;
        public clearValue(): void;
        public fragment : TimelineTimeseriesFragmentModel;
        public index : number;
        public changed : Notification;
        public times_PMILLIS : number;
        public data : number;
    }
    class TimeIntervalModel {
        private _start_PMILLIS;
        private _end_PMILLIS;
        private _cursor_PMILLIS;
        private _changed;
        constructor(start_PMILLIS: number, end_PMILLIS: number, cursor_PMILLIS?: number);
        public start_PMILLIS : number;
        public end_PMILLIS : number;
        public cursor_PMILLIS : number;
        public duration_MILLIS : number;
        public changed : Notification;
        public setInterval(start_PMILLIS: number, end_PMILLIS: number, cursor_PMILLIS?: number): void;
        public overlaps(start_PMILLIS: number, end_PMILLIS: number): boolean;
        public contains(time_PMILLIS: number): boolean;
        public pan(amount_MILLIS: number): void;
        public scale(factor: number, anchor_PMILLIS: number): void;
    }
}
declare module Webglimpse {
    interface TimelineRowPaneOptions {
        timelineFont: string;
        timelineFgColor: Color;
        draggableEdgeWidth: number;
        snapToDistance: number;
        isMaximized: boolean;
        mouseWheelListener?: (PointerEvent: any) => void;
    }
    interface TimelineRowPaneFactory {
        (drawable: Drawable, timeAxis: TimeAxis1D, dataAxis: Axis1D, model: TimelineModel, row: TimelineRowModel, ui: TimelineUi, options: TimelineRowPaneOptions): Pane;
    }
    interface TimelineRowPaneFactoryChooser {
        (row: TimelineRowModel): TimelineRowPaneFactory;
    }
}
declare module Webglimpse {
    class TimelineLaneArray {
        private _ui;
        private _row;
        private _lanes;
        private _laneNums;
        private _rebuildLanesMouseWheel;
        private _rebuildLanes;
        private _newEvent;
        private _addEvent;
        private _removeEvent;
        private _model;
        private _eventAttrsListeners;
        constructor(model: TimelineModel, row: TimelineRowModel, ui: TimelineUi, allowMultipleLanes: boolean);
        public length : number;
        public lane(index: number): TimelineLane;
        public numEvents : number;
        public eventAt(laneNum: number, time_PMILLIS: number): TimelineEventModel;
        public dispose(): void;
    }
    function effectiveEdges_PMILLIS(ui: TimelineUi, event: TimelineEventModel): number[];
    interface TimelineLane {
        length: number;
        event(index: number): TimelineEventModel;
        isEmpty(): boolean;
        eventAtTime(time_PMILLIS: number): TimelineEventModel;
        add(event: TimelineEventModel): any;
        remove(event: TimelineEventModel): any;
        eventStillFits(event: TimelineEventModel): boolean;
        update(event: TimelineEventModel): any;
        collisionsWithInterval(start_PMILLIS: number, end_PMILLIS: number): TimelineEventModel[];
        couldFitEvent(event: TimelineEventModel): boolean;
    }
    class TimelineLaneStack implements TimelineLane {
        private _events;
        private _starts_PMILLIS;
        private _ends_PMILLIS;
        private _indices;
        private _ui;
        constructor(ui: TimelineUi);
        public length : number;
        public event(index: number): TimelineEventModel;
        public isEmpty(): boolean;
        public eventAtTime(time_PMILLIS: number): TimelineEventModel;
        public add(event: TimelineEventModel): void;
        public remove(event: TimelineEventModel): void;
        public eventStillFits(event: TimelineEventModel): boolean;
        public update(event: TimelineEventModel): void;
        public collisionsWithInterval(start_PMILLIS: number, end_PMILLIS: number): TimelineEventModel[];
        public couldFitEvent(event: TimelineEventModel): boolean;
        public _eventFitsBetween(event: TimelineEventModel, iBefore: number, iAfter: number): boolean;
    }
    class TimelineLaneSimple implements TimelineLane {
        private _events;
        private _orders;
        private _ids;
        private _ui;
        constructor(ui: TimelineUi);
        public length : number;
        public event(index: number): TimelineEventModel;
        public isEmpty(): boolean;
        public eventAtTime(time_PMILLIS: number): TimelineEventModel;
        public add(event: TimelineEventModel): void;
        public remove(event: TimelineEventModel): void;
        public update(event: TimelineEventModel): void;
        public collisionsWithInterval(start_PMILLIS: number, end_PMILLIS: number): TimelineEventModel[];
        public eventStillFits(event: TimelineEventModel): boolean;
        public couldFitEvent(event: TimelineEventModel): boolean;
        public _getIndex(queryEvent: TimelineEventModel): number;
    }
}
declare module Webglimpse {
    interface TimelineEventsPainterOptions {
        timelineFont: string;
        timelineFgColor: Color;
        rowTopPadding: number;
        rowBottomPadding: number;
        laneHeight: number;
    }
    interface TimelineEventsPainterFactory {
        (drawable: Drawable, timeAxis: TimeAxis1D, lanes: TimelineLaneArray, ui: TimelineUi, options: TimelineEventsPainterOptions): Painter;
    }
    interface TimelineEventsRowPaneOptions {
        rowTopPadding?: number;
        rowBottomPadding?: number;
        laneHeight?: number;
        allowMultipleLanes?: boolean;
        painterFactories?: TimelineEventsPainterFactory[];
    }
    function newEventsRowPaneFactory(eventsRowOpts?: TimelineEventsRowPaneOptions): TimelineRowPaneFactory;
    interface TimelineEventLimitsPainterOptions {
        lineColor?: Color;
        lineThickness?: number;
    }
    function newEventLimitsPainterFactory(limitOpts?: TimelineEventLimitsPainterOptions): TimelineEventsPainterFactory;
    enum JointType {
        BEVEL = 0,
        MITER = 1,
    }
    interface TimelineEventBarsPainterOptions {
        topMargin?: number;
        bottomMargin?: number;
        borderThickness?: number;
        cornerType?: JointType;
        defaultColor?: Color;
        defaultBorderColor?: Color;
        selectedBorderColor?: Color;
        dashLength?: number;
        stripeWidth?: number;
        stripeSecondaryWidth?: number;
        stripeSlant?: number;
        featherWidth?: number;
        minimumVisibleWidth?: number;
    }
    enum FillPattern {
        solid = 0,
        stripe = 1,
        gradient = 2,
    }
    function newEventStripedBarsPainterFactory(barOpts?: TimelineEventBarsPainterOptions): TimelineEventsPainterFactory;
    function newEventDashedBordersPainterFactory(barOpts?: TimelineEventBarsPainterOptions): TimelineEventsPainterFactory;
    interface TimelineEventIconsPainterOptions {
        topMargin?: number;
        bottomMargin?: number;
        vAlign?: number;
    }
    function newEventIconsPainterFactory(iconOpts?: TimelineEventIconsPainterOptions): TimelineEventsPainterFactory;
    interface TimelineEventLabelOptions {
        topMargin?: number;
        bottomMargin?: number;
        leftMargin?: number;
        rightMargin?: number;
        vAlign?: number;
        spacing?: number;
        extendBeyondBar?: boolean;
        textMode?: string;
        iconsEnabled?: boolean;
        iconsForceWidth?: any;
        iconsForceHeight?: any;
        iconsSizeFactor?: number;
        textEnabled?: boolean;
        textDefaultColor?: Color;
        textFont?: string;
    }
    function newEventLabelsPainterFactory(labelOpts?: TimelineEventLabelOptions): TimelineEventsPainterFactory;
    function newEventBarsPainterFactory(barOpts?: TimelineEventBarsPainterOptions): TimelineEventsPainterFactory;
    function newCombinedEventPainterFactory(barOpts?: TimelineEventBarsPainterOptions, labelOpts?: TimelineEventLabelOptions, iconOpts?: TimelineEventIconsPainterOptions): TimelineEventsPainterFactory;
}
declare module Webglimpse {
    interface TimelineTimeseriesPainterOptions {
        timelineFont: string;
        timelineFgColor: Color;
        timelineThickness: number;
        rowTopPadding: number;
        rowBottomPadding: number;
    }
    interface TimelineTimeseriesPainterFactory {
        (drawable: Drawable, timeAxis: TimeAxis1D, dataAxis: Axis1D, model: TimelineModel, rowModel: TimelineRowModel, ui: TimelineUi, options: TimelineTimeseriesPainterOptions): Painter;
    }
    interface TimelineTimeseriesRowPaneOptions {
        rowHeight?: number;
        rowTopPadding?: number;
        rowBottomPadding?: number;
        axisOptions?: EdgeAxisPainterOptions;
        axisWidth?: number;
        painterFactories?: TimelineTimeseriesPainterFactory[];
    }
    function newTimeseriesRowPaneFactory(rowOptions?: TimelineTimeseriesRowPaneOptions): TimelineRowPaneFactory;
    function newTimeseriesPainterFactory(options?: TimelineTimeseriesPainterOptions): TimelineTimeseriesPainterFactory;
}
declare module Webglimpse {
    var timeseriesRowPainterFactories_DEFAULT: TimelineTimeseriesPainterFactory[];
    var eventsRowPaneFactory_DEFAULT: TimelineRowPaneFactory;
    var timeseriesRowPaneFactory_DEFAULT: TimelineRowPaneFactory;
    function rowPaneFactoryChooser_DEFAULT(row: TimelineRowModel): TimelineRowPaneFactory;
    var eventsRowPaneFactory_THIN: TimelineRowPaneFactory;
    function rowPaneFactoryChooser_THIN(row: TimelineRowModel): TimelineRowPaneFactory;
    var eventsRowPaneFactory_SINGLE: TimelineRowPaneFactory;
    function rowPaneFactoryChooser_SINGLE(row: TimelineRowModel): TimelineRowPaneFactory;
}
declare module Webglimpse {
    class TimelinePane extends Pane {
        private _model;
        private _ui;
        constructor(layout: Layout, model: TimelineModel, ui: TimelineUi);
        public model : TimelineModel;
        public ui : TimelineUi;
    }
    interface TimelinePaneOptions {
        font?: string;
        rowPaneFactoryChooser?: TimelineRowPaneFactoryChooser;
        showScrollbar?: boolean;
        scrollbarOptions?: ScrollbarOptions;
        fgColor?: Color;
        rowLabelColor?: Color;
        rowLabelBgColor?: Color;
        groupLabelColor?: Color;
        axisLabelColor?: Color;
        bgColor?: Color;
        rowBgColor?: Color;
        rowAltBgColor?: Color;
        gridColor?: Color;
        selectedIntervalFillColor?: Color;
        selectedIntervalBorderColor?: Color;
        showTopAxis?: boolean;
        showBottomAxis?: boolean;
        topTimeZone?: string;
        bottomTimeZone?: string;
        tickSpacing?: number;
        axisLabelAlign?: number;
        isFuturePositive?: boolean;
        referenceDate?: string;
        groupLabelInsets?: Insets;
        rowLabelInsets?: Insets;
        rowLabelPaneWidth?: number;
        rowSeparatorHeight?: number;
        scrollbarWidth?: number;
        axisPaneHeight?: number;
        draggableEdgeWidth?: number;
        snapToDistance?: number;
        allowEventMultiSelection?: boolean;
        selectedIntervalMode?: string;
        centerSelectedIntervalOnDoubleClick?: boolean;
        mouseWheelListener?: (PointerEvent: any) => void;
    }
    function newTimelinePane(drawable: Drawable, timeAxis: TimeAxis1D, model: TimelineModel, options?: TimelinePaneOptions, ui?: TimelineUi): TimelinePane;
}
